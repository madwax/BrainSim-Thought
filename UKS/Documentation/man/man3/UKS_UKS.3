.TH "UKS.UKS" 3 "UKS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
UKS.UKS \- Contains a collection of Thoughts linked by Links to implement Common Sense and general knowledge\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBsThought\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBCreateInitialStructure\fP ()"
.br
.ti -1c
.RI "\fBUKS\fP (bool clear=false)"
.br
.RI "Creates a new reference to the \fBUKS\fP and initializes it if it is the first reference\&. "
.ti -1c
.RI "virtual \fBThought\fP \fBAddThought\fP (string label, \fBThought\fP? parent)"
.br
.RI "This is a primitive method needed only to create ROOT Thoughts which have no parents\&. "
.ti -1c
.RI "\fBThought\fP \fBLabeled\fP (string label)"
.br
.RI "Uses a hash table to return the \fBThought\fP with the given label or null if it does not exist\&. "
.ti -1c
.RI "virtual void \fBDeleteThought\fP (\fBThought\fP t)"
.br
.RI "This is a primitive method to delete a \fBThought\fP; the \fBThought\fP must not have any children\&. "
.ti -1c
.RI "\fBThought\fP \fBGetLink\fP (\fBThought\fP from, \fBThought\fP linkType, \fBThought\fP to)"
.br
.RI "Gets an existing link matching the specified from/linkType/to triple, if present\&. "
.ti -1c
.RI "\fBThought\fP \fBGetLink\fP (\fBThought\fP r)"
.br
.RI "Gets an existing link matching the supplied link prototype\&. "
.ti -1c
.RI "List< \fBThought\fP > \fBGetLinks\fP (\fBThought\fP r)"
.br
.RI "Gets all links from the same source matching the prototype's LinkType and To\&. "
.ti -1c
.RI "void \fBDeleteAllChildren\fP (\fBThought\fP t)"
.br
.RI "Recursively removes all the descendants of a \fBThought\fP\&. If these descendants have no other parents, they will be deleted as well\&. "
.ti -1c
.RI "\fBThought\fP \fBGetOrAddThought\fP (string label, object parent=null, \fBThought\fP source=null)"
.br
.RI "Creates a new \fBThought\fP in the \fBUKS\fP OR returns an existing \fBThought\fP, based on the label\&. "
.ti -1c
.RI "\fBThought\fP \fBCreateThoughtFromMultipleAttributes\fP (string label, bool attributesFollow, bool singularize=true)"
.br
.RI "Finds or creates a subclass from a phrase, attaching attributes as dotted parts\&. Example: "has 4" becomes thought {has\&.4} and [has\&.4 is 4]\&. "
.ti -1c
.RI "List< \fBThought\fP > \fBGetAllLinks\fP (List< \fBThought\fP > sources)"
.br
.RI "Gets all links to a group of Thoughts including inherited links\&. "
.ti -1c
.RI "IReadOnlyList< \fBThought\fP > \fBFilterResults\fP (List< \fBThought\fP > result, List< \fBThought\fP > ancestors)"
.br
.RI "Filters a list of Links returning only those with at least one component which has an ancestor in the list of ancestors\&. "
.ti -1c
.RI "List< \fBThought\fP > \fBWhyNot\fP ()"
.br
.RI "Returns a list of Links which were false in the previous query\&. "
.ti -1c
.RI "List< \fBThought\fP > \fBWhy\fP ()"
.br
.RI "Returns a list of Links which were true in the previous query\&. "
.ti -1c
.RI "List<(\fBThought\fP t, float conf)> \fBSearchForClosestMatch\fP (\fBThought\fP target, \fBThought\fP root)"
.br
.RI "Search for the \fBThought\fP which most closely resembles the target \fBThought\fP based on the attributes of the target\&. "
.ti -1c
.RI "float \fBGetLinkWeight\fP (\fBThought\fP t1, \fBThought\fP t2)"
.br
.RI "DEPRECATED: Helper for SearchForClosestMatch that gets the weight of the link between two Thoughts\&. "
.ti -1c
.RI "bool \fBThoughtsHaveSimilarLink\fP (\fBThought\fP source, \fBThought\fP target)"
.br
.RI "DEPRECATED Determines whether two thoughts share at least one similar link (same link type and compatible targets)\&. "
.ti -1c
.RI "bool \fBIsSequenceElement\fP (\fBThought\fP t)"
.br
.RI "Determines whether a \fBThought\fP participates as a sequence element (has a FRST link)\&. "
.ti -1c
.RI "\fBThought\fP \fBGetElementValue\fP (\fBThought\fP t)"
.br
.RI "Gets the single VLU target value of a sequence node\&. "
.ti -1c
.RI "\fBThought\fP \fBInsertElement\fP (\fBThought\fP prevElementIn, \fBThought\fP value)"
.br
.RI "Inserts a new element at the beginning of the sequence, shifting the previous first element forward\&. "
.ti -1c
.RI "\fBThought\fP \fBCreateFirstElement\fP (\fBThought\fP source, \fBThought\fP value)"
.br
.RI "Creates the first sequence element for a source \fBThought\fP and links its value\&. "
.ti -1c
.RI "\fBThought\fP \fBAddSequence\fP (\fBThought\fP source, \fBThought\fP linkType, List< \fBThought\fP > targets, float baseWeight=1\&.0f)"
.br
.RI "Adds a sequence of Thoughts as ordered links from a source \fBThought\fP\&. Handles nested sequences\&. "
.ti -1c
.RI "List<(\fBThought\fP r, float confidence)> \fBHasSequence\fP (List< \fBThought\fP > targets, \fBThought\fP linkType, bool mustMatchFirst=false, bool mustMatchLast=false, bool circularSearch=false, bool allowOutOfOrder=false)"
.br
.RI "Finds sequences matching the ordered targets and returns candidate links with confidence scores\&. "
.ti -1c
.RI "List< \fBThought\fP > \fBFlattenSequence\fP (\fBThought\fP sequenceStart)"
.br
.RI "Flatten a sequence into a list of leaf Thoughts (letters)\&. Handles nested sequences via VLU\&. "
.ti -1c
.RI "IEnumerable< \fBThought\fP > \fBEnumerateSequenceElements\fP (\fBThought\fP sequenceStart, Stack< \fBThought\fP > visitedSequences=null)"
.br
.RI "Enumerates all leaf elements in a sequence, recursively traversing into subsequences\&. Protected against circular subsequence references\&. "
.ti -1c
.RI "\fBThought\fP \fBAddStatement\fP (string sSource, string sLinkType, string sTarget, string label='')"
.br
.RI "Creates a \fBThought\fP\&. 
.br
 Parameters are strings\&. If the Thoughts with those labels do not exist, they will be created\&. 
.br
 If the LinkType has an inverse, the inverse will be used and the \fBThought\fP will be reversed so that Fido Is-a Dog become Dog Has-child Fido\&.
.br
\&. "
.ti -1c
.RI "\fBThought\fP \fBAddStatement\fP (\fBThought\fP source, \fBThought\fP linkType, \fBThought\fP target, string label='')"
.br
.RI "Adds a statement relating the specified source, link type, and target\&. No new Thoughts are created\&. "
.ti -1c
.RI "\fBThought\fP \fBSubclassExists\fP (\fBThought\fP t, List< \fBThought\fP > thoughtAttributes, ref \fBThought\fP bestMatch, ref List< \fBThought\fP > missingAttributes)"
.br
.ti -1c
.RI "\fBThought\fP \fBCreateInstanceOf\fP (\fBThought\fP t)"
.br
.ti -1c
.RI "void \fBExportTextFile\fP (string root, string path, int maxDepth=12)"
.br
.RI "Export a neighborhood starting from \fIroot\fP  to the bracketed txt file format\&. Emits facts as [S,R,O] (or [S,R,O,N] when R is a numeric specialization like "has\&.4")\&. Optionally emits simple clause pairs if \fBThought\fP exposes a Clauses collection\&. "
.ti -1c
.RI "void \fBImportTextFile\fP (string filePath)"
.br
.RI "Imports \fBUKS\fP content from a bracketed text file\&. "
.ti -1c
.RI "bool \fBSaveUKStoXMLFile\fP (string filenameIn='')"
.br
.RI "Saves the \fBUKS\fP content to an XML file\&. "
.ti -1c
.RI "bool \fBLoadUKSfromXMLFile\fP (string filenameIn='')"
.br
.RI "Loads \fBUKS\fP content from a previously-saved XML file\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBWriteTheLink\fP (\fBThought\fP r)"
.br
.ti -1c
.RI "static bool \fBCanWriteToFile\fP (string fileName, out string message)"
.br
.RI "Checks whether the specified file can be opened for writing\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static List< \fBThought\fP > \fBtransientLinks\fP = new List<\fBThought\fP>()"
.br
.ti -1c
.RI "static \fBUKS\fP \fBtheUKS\fP = new \fBUKS\fP()"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "List< \fBThought\fP > \fBAllThoughts\fP\fR [get]\fP"
.br
.RI "Occasionally a list of all the Thoughts in the \fBUKS\fP is needed\&. This is READ ONLY\&. There is only one (shared) list for the App\&. "
.ti -1c
.RI "string \fBFileName\fP\fR [get]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Contains a collection of Thoughts linked by Links to implement Common Sense and general knowledge\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "UKS\&.UKS\&.UKS (bool clear = \fRfalse\fP)"

.PP
Creates a new reference to the \fBUKS\fP and initializes it if it is the first reference\&. 
.PP
\fBParameters\fP
.RS 4
\fIclear\fP When true, clears existing thoughts and label cache before initialization\&.
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBThought\fP UKS\&.UKS\&.AddSequence (\fBThought\fP source, \fBThought\fP linkType, List< \fBThought\fP > targets, float baseWeight = \fR1::0f\fP)"

.PP
Adds a sequence of Thoughts as ordered links from a source \fBThought\fP\&. Handles nested sequences\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP The 'owner' of the sequence\&.
.br
\fIlinkType\fP The link type to use for the sequence relationship\&.
.br
\fItargets\fP Targets in order; can be sequence start nodes\&.
.br
\fIbaseWeight\fP Base weight for the links (currently unused)\&.
.RE
.PP
\fBReturns\fP
.RS 4
The first node of the created or reused sequence, or null if insufficient targets\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.AddStatement (string sSource, string sLinkType, string sTarget, string label = \fR''\fP)"

.PP
Creates a \fBThought\fP\&. 
.br
 Parameters are strings\&. If the Thoughts with those labels do not exist, they will be created\&. 
.br
 If the LinkType has an inverse, the inverse will be used and the \fBThought\fP will be reversed so that Fido Is-a Dog become Dog Has-child Fido\&.
.br
\&. 
.PP
\fBParameters\fP
.RS 4
\fIsSource\fP string or \fBThought\fP for the source\&.
.br
\fIsLinkType\fP string or \fBThought\fP for the link type\&.
.br
\fIsTarget\fP string or \fBThought\fP (or null) for the target\&.
.br
\fIlabel\fP Optional label for the created link \fBThought\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
The primary link which was created (others may be created for given attributes)\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.AddStatement (\fBThought\fP source, \fBThought\fP linkType, \fBThought\fP target, string label = \fR''\fP)"

.PP
Adds a statement relating the specified source, link type, and target\&. No new Thoughts are created\&. If a link with the same source, link type, and target already exists, the existing link is returned after being activated\&. Otherwise, a new link is created and added\&. If the link type has the "isCommutative" property, a reverse link is also created\&. Additionally, any extraneous parent links for the source, target, or link type are cleared\&.

.PP
\fBParameters\fP
.RS 4
\fIsource\fP The source \fBThought\fP of the link\&. Cannot be \fRnull\fP\&.
.br
\fIlinkType\fP The link type \fBThought\fP\&. Cannot be \fRnull\fP\&.
.br
\fItarget\fP The target \fBThought\fP of the link\&.
.br
\fIlabel\fP Optional label for the created link \fBThought\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created or existing \fBThought\fP object that represents the link\&. Returns \fRnull\fP if \fIsource\fP  or \fIlinkType\fP  is \fRnull\fP\&.
.RE
.PP

.SS "virtual \fBThought\fP UKS\&.UKS\&.AddThought (string label, \fBThought\fP? parent)\fR [virtual]\fP"

.PP
This is a primitive method needed only to create ROOT Thoughts which have no parents\&. 
.PP
\fBParameters\fP
.RS 4
\fIlabel\fP Label of the thought to create\&.
.br
\fIparent\fP Optional parent thought (may be null)\&.
.RE
.PP
\fBReturns\fP
.RS 4
The newly created thought\&.
.RE
.PP

.SS "bool UKS\&.UKS\&.CanWriteToFile (string fileName, out string message)\fR [static]\fP"

.PP
Checks whether the specified file can be opened for writing\&. 
.PP
\fBParameters\fP
.RS 4
\fIfileName\fP Path to test for write access\&.
.br
\fImessage\fP Outputs the error message if access fails\&.
.RE
.PP
\fBReturns\fP
.RS 4
\fRtrue\fP if the file is writable; otherwise \fRfalse\fP\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.CreateThoughtFromMultipleAttributes (string label, bool attributesFollow, bool singularize = \fRtrue\fP)"

.PP
Finds or creates a subclass from a phrase, attaching attributes as dotted parts\&. Example: "has 4" becomes thought {has\&.4} and [has\&.4 is 4]\&. 
.PP
\fBParameters\fP
.RS 4
\fIlabel\fP Input phrase to process\&.
.br
\fIattributesFollow\fP True if attributes follow the base term; false if they precede it\&.
.br
\fIsingularize\fP When true, singularizes non-capitalized words\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created or retrieved \fBThought\fP\&.
.RE
.PP

.SS "void UKS\&.UKS\&.DeleteAllChildren (\fBThought\fP t)"

.PP
Recursively removes all the descendants of a \fBThought\fP\&. If these descendants have no other parents, they will be deleted as well\&. 
.PP
\fBParameters\fP
.RS 4
\fIt\fP The thought to remove the children from\&.
.RE
.PP

.SS "virtual void UKS\&.UKS\&.DeleteThought (\fBThought\fP t)\fR [virtual]\fP"

.PP
This is a primitive method to delete a \fBThought\fP; the \fBThought\fP must not have any children\&. 
.PP
\fBParameters\fP
.RS 4
\fIt\fP The thought to delete\&.
.RE
.PP

.SS "IEnumerable< \fBThought\fP > UKS\&.UKS\&.EnumerateSequenceElements (\fBThought\fP sequenceStart, Stack< \fBThought\fP > visitedSequences = \fRnull\fP)"

.PP
Enumerates all leaf elements in a sequence, recursively traversing into subsequences\&. Protected against circular subsequence references\&. 
.PP
\fBParameters\fP
.RS 4
\fIsequenceStart\fP The first node of the sequence\&.
.br
\fIvisitedSequences\fP Optional stack to track visited sequences across recursion\&.
.RE
.PP
\fBReturns\fP
.RS 4
Leaf sequence elements in order\&.
.RE
.PP

.SS "void UKS\&.UKS\&.ExportTextFile (string root, string path, int maxDepth = \fR12\fP)"

.PP
Export a neighborhood starting from \fIroot\fP  to the bracketed txt file format\&. Emits facts as [S,R,O] (or [S,R,O,N] when R is a numeric specialization like "has\&.4")\&. Optionally emits simple clause pairs if \fBThought\fP exposes a Clauses collection\&. 
.PP
\fBParameters\fP
.RS 4
\fIroot\fP Label of the starting thought to export\&.
.br
\fIpath\fP Destination file path for the exported text\&.
.br
\fImaxDepth\fP Optional maximum traversal depth (currently unused)\&.
.RE
.PP

.SS "IReadOnlyList< \fBThought\fP > UKS\&.UKS\&.FilterResults (List< \fBThought\fP > result, List< \fBThought\fP > ancestors)"

.PP
Filters a list of Links returning only those with at least one component which has an ancestor in the list of ancestors\&. 
.PP
\fBParameters\fP
.RS 4
\fIresult\fP List of links from a previous query\&.
.br
\fIancestors\fP Ancestor filter list\&.
.RE
.PP
\fBReturns\fP
.RS 4
Filtered list containing only links that match the ancestor filter\&.
.RE
.PP

.SS "List< \fBThought\fP > UKS\&.UKS\&.GetAllLinks (List< \fBThought\fP > sources)"

.PP
Gets all links to a group of Thoughts including inherited links\&. 
.PP
\fBParameters\fP
.RS 4
\fIsources\fP Thoughts that seed the search for related links\&.
.RE
.PP
\fBReturns\fP
.RS 4
List of matching links\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.GetElementValue (\fBThought\fP t)"

.PP
Gets the single VLU target value of a sequence node\&. 
.PP
\fBParameters\fP
.RS 4
\fIt\fP Sequence element to read\&.
.RE
.PP
\fBReturns\fP
.RS 4
The linked VLU value, or null if none\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.GetLink (\fBThought\fP from, \fBThought\fP linkType, \fBThought\fP to)"

.PP
Gets an existing link matching the specified from/linkType/to triple, if present\&. 
.PP
\fBParameters\fP
.RS 4
\fIfrom\fP Source thought of the link\&.
.br
\fIlinkType\fP Relationship type thought\&.
.br
\fIto\fP Target thought of the link\&.
.RE
.PP
\fBReturns\fP
.RS 4
The existing link \fBThought\fP, or null if not found\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.GetLink (\fBThought\fP r)"

.PP
Gets an existing link matching the supplied link prototype\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP Link prototype (From, LinkType, To) to search for\&.
.RE
.PP
\fBReturns\fP
.RS 4
The existing link \fBThought\fP, or null if not found\&.
.RE
.PP

.SS "List< \fBThought\fP > UKS\&.UKS\&.GetLinks (\fBThought\fP r)"

.PP
Gets all links from the same source matching the prototype's LinkType and To\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP Link prototype containing source, link type, and target\&.
.RE
.PP
\fBReturns\fP
.RS 4
List of matching link Thoughts\&.
.RE
.PP

.SS "float UKS\&.UKS\&.GetLinkWeight (\fBThought\fP t1, \fBThought\fP t2)"

.PP
DEPRECATED: Helper for SearchForClosestMatch that gets the weight of the link between two Thoughts\&. 
.PP
\fBParameters\fP
.RS 4
\fIt1\fP First thought\&.
.br
\fIt2\fP Second thought\&.
.RE
.PP
\fBReturns\fP
.RS 4
Weight of the direct link between the two thoughts, or 0 if none\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.GetOrAddThought (string label, object parent = \fRnull\fP, \fBThought\fP source = \fRnull\fP)"

.PP
Creates a new \fBThought\fP in the \fBUKS\fP OR returns an existing \fBThought\fP, based on the label\&. 
.PP
\fBParameters\fP
.RS 4
\fIlabel\fP Label for the thought\&. Trailing '*' auto-increments to a unique label\&.
.br
\fIparent\fP Optional parent thought or label; defaults to "Unknown" if null\&.
.br
\fIsource\fP Optional source thought used to probe existing numbered links\&.
.RE
.PP
\fBReturns\fP
.RS 4
The existing or newly created \fBThought\fP\&.
.RE
.PP

.SS "List<(\fBThought\fP r, float confidence)> UKS\&.UKS\&.HasSequence (List< \fBThought\fP > targets, \fBThought\fP linkType, bool mustMatchFirst = \fRfalse\fP, bool mustMatchLast = \fRfalse\fP, bool circularSearch = \fRfalse\fP, bool allowOutOfOrder = \fRfalse\fP)"

.PP
Finds sequences matching the ordered targets and returns candidate links with confidence scores\&. 
.PP
\fBParameters\fP
.RS 4
\fItargets\fP Pattern to search for\&.
.br
\fIlinkType\fP Specific link type to follow; null matches all sequence link types\&.
.br
\fImustMatchFirst\fP Require candidate to start at the first sequence element\&.
.br
\fImustMatchLast\fP Require candidate to end at the last sequence element\&.
.br
\fIcircularSearch\fP Reserved for circular search (not implemented)\&.
.br
\fIallowOutOfOrder\fP Reserved for out-of-order search (not implemented)\&.
.RE
.PP
\fBReturns\fP
.RS 4
List of candidate links with confidence values\&.
.RE
.PP
AND the order of the elements will be lower priority if all intervening elements are found\&. 
.br
 Example: given the stored sequance S E A T , S A E T would match with higher confidence than E S A T
.SS "void UKS\&.UKS\&.ImportTextFile (string filePath)"

.PP
Imports \fBUKS\fP content from a bracketed text file\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilePath\fP Path of the text file to import\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.InsertElement (\fBThought\fP prevElementIn, \fBThought\fP value)"

.PP
Inserts a new element at the beginning of the sequence, shifting the previous first element forward\&. 
.PP
\fBParameters\fP
.RS 4
\fIprevElementIn\fP Current first sequence element\&.
.br
\fIvalue\fP Value to insert as the new first element\&.
.RE
.PP
\fBReturns\fP
.RS 4
The (updated) first element of the sequence\&.
.RE
.PP

.SS "bool UKS\&.UKS\&.IsSequenceElement (\fBThought\fP t)"

.PP
Determines whether a \fBThought\fP participates as a sequence element (has a FRST link)\&. 
.PP
\fBParameters\fP
.RS 4
\fIt\fP \fBThought\fP to test\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if the thought has a FRST link; otherwise false\&.
.RE
.PP

.SS "\fBThought\fP UKS\&.UKS\&.Labeled (string label)"

.PP
Uses a hash table to return the \fBThought\fP with the given label or null if it does not exist\&. 
.PP
\fBParameters\fP
.RS 4
\fIlabel\fP Label to look up\&.
.RE
.PP
\fBReturns\fP
.RS 4
The \fBThought\fP or null\&.
.RE
.PP

.SS "bool UKS\&.UKS\&.LoadUKSfromXMLFile (string filenameIn = \fR''\fP)"

.PP
Loads \fBUKS\fP content from a previously-saved XML file\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilenameIn\fP Optional file name; when null or empty, the previous file name is reused\&.
.RE
.PP
\fBReturns\fP
.RS 4
\fRtrue\fP if the load succeeded; otherwise \fRfalse\fP\&.
.RE
.PP

.SS "bool UKS\&.UKS\&.SaveUKStoXMLFile (string filenameIn = \fR''\fP)"

.PP
Saves the \fBUKS\fP content to an XML file\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilenameIn\fP Optional file name; when null or empty, the previous file name is reused\&.
.RE
.PP
\fBReturns\fP
.RS 4
\fRtrue\fP if the save succeeded; otherwise \fRfalse\fP\&.
.RE
.PP

.SS "List<(\fBThought\fP t, float conf)> UKS\&.UKS\&.SearchForClosestMatch (\fBThought\fP target, \fBThought\fP root)"

.PP
Search for the \fBThought\fP which most closely resembles the target \fBThought\fP based on the attributes of the target\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP The links of this \fBThought\fP are the attributes to search on\&.
.br
\fIroot\fP All searching is done within the descendants of this \fBThought\fP\&.
.br
\fIconfidence\fP Unused output parameter reserved for match quality (not currently assigned)\&.
.RE
.PP
\fBReturns\fP
.RS 4
Ordered list of candidate thoughts with confidence scores\&.
.RE
.PP

.SS "bool UKS\&.UKS\&.ThoughtsHaveSimilarLink (\fBThought\fP source, \fBThought\fP target)"

.PP
DEPRECATED Determines whether two thoughts share at least one similar link (same link type and compatible targets)\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP First thought to compare\&.
.br
\fItarget\fP Second thought to compare\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if a similar link exists; otherwise false\&.
.RE
.PP

.SS "List< \fBThought\fP > UKS\&.UKS\&.Why ()"

.PP
Returns a list of Links which were true in the previous query\&. 
.PP
\fBReturns\fP
.RS 4
Links that succeeded conditional evaluation\&.
.RE
.PP

.SS "List< \fBThought\fP > UKS\&.UKS\&.WhyNot ()"

.PP
Returns a list of Links which were false in the previous query\&. 
.PP
\fBReturns\fP
.RS 4
Links that failed conditional evaluation\&.
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for UKS from the source code\&.
